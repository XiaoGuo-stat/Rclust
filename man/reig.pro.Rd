% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reig.pro.R
\name{reig.pro}
\alias{reig.pro}
\title{Compute randomized eigenvalue decomposition of the adjacency matrix of undirected networks using random projection}
\usage{
reig.pro(
  A,
  rank,
  p = 10,
  q = 2,
  dist = "normal",
  approA = FALSE,
  nthread = 1,
  abs = FALSE
)
}
\arguments{
\item{A}{Input data matrix of class "\code{dgCMatrix}". The matrix is assumed to be binary,
symmetric, and sparse, with zeros on the diagonal.}

\item{rank}{The target rank of the low-rank decomposition.}

\item{p}{The oversampling parameter. It need to be a positive integer number. Default value is 10.}

\item{q}{The power parameter. It need to be a positive integer number. Default value is 2.}

\item{dist}{The distribution of the entry of the random test matrix. Can be \code{"normal"} (standard normal distribution),
\code{"unif"} (uniform distribution from -1 to 1), or \code{"rademacher"} (randemacher distribution). Default
is \code{"normal"}.}

\item{approA}{A logical variable indicating whether the approximated \code{A} is returned. Default is \code{FALSE}.}

\item{nthread}{Maximum number of threads for specific computations that could be implemented in parallel. Default is 1.}

\item{abs}{A logical variable indicating whether the \code{rank+p} eigen values should be largest in absolute value.
Default is \code{FALSE}, indicating that the eigen values are largest in value.}
}
\value{
\item{vectors}{The randomized \code{rank+p} eigen vectors.}
        \item{values}{The \code{rank+p} eigen values.}
        \item{approA}{The approximated data matrix if requested.}
}
\description{
Compute the randomized eigenvalue decomposition of an adjacency matrix (0-1 coded) by random projection.
The randomized eigen vectors and eigen values are computed. Can deal with very large
data matrix.
}
\details{
This function computes the randomized eigen value decomposition of an adjacency matrix using the random
projection scheme. The data matrix \code{A} is symmetric and binary. It is first compressed to a
smaller matrix with its columns (rows) being the linear combinations of the
columns (rows) of \code{A}. The classical eigen value decomposition is then performed on the smaller
matrix. The randomized eigen value decomposition of \code{A} are obtained by postprocessing.
}
\examples{
set.seed(123)
n <- 100
rank <- 2
clustertrue <- rep(1:rank, each = n/rank)
A <- matrix(0, n, n)
for(i in 1:(n - 1)) {
    for(j in (i + 1):n) {
        A[i, j] <- ifelse(clustertrue[i] == clustertrue[j], rbinom(1, 1, 0.2), rbinom(1, 1, 0.1))
    }
}
diag(A) <- 0
A <- A + t(A)
A <- as(A, "dgCMatrix")
reig.pro(A, rank)

}
\references{
N. Halko, P.-G. Martinsson, and J. A. Tropp. (2011)
\emph{Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions},
\emph{SIAM review, Vol. 53(2), 217-288}\cr
\url{https://epubs.siam.org/doi/10.1137/090771806}\cr
}
